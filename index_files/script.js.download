var lang_code = document.documentElement.lang;
if (lang_code == 'ar') {
    lang_code = 'en'
}
var total_count = $('#totalCount').data('total_count')+1;
var people_vaccinated = parseFloat($('#tilePeopleVaccinated').data('people_vaccinated'))+1;
var people_fully_vaccinated = parseFloat($('#tilePeopleFullyVaccinated').data('people_fully_vaccinated'))+1;
var ratio = $('#tilePeopleFullyVaccinated').data('dose_ratio');
var rate = $('#rate').data('rate');

if (rate > 0 ) {

    setInterval(function(){
        document.getElementById('totalCount').innerHTML = total_count.toLocaleString(lang_code);
        if (document.getElementById('tableTotalCount')) {
            document.getElementById('tableTotalCount').innerHTML = total_count.toLocaleString(lang_code);
        }
        if (document.getElementById('tileTotalCount')) {
            document.getElementById('tileTotalCount').innerHTML = total_count.toLocaleString(lang_code);
            if (Math.random() > ratio) {
                if (document.getElementById('tilePeopleVaccinated')) {
                    document.getElementById('tilePeopleVaccinated').innerHTML = people_vaccinated.toLocaleString(lang_code);
                    people_vaccinated++;
                }
            } else {
                if (document.getElementById('tilePeopleFullyVaccinated')) {
                    document.getElementById('tilePeopleFullyVaccinated').innerHTML = people_fully_vaccinated.toLocaleString(lang_code);
                    people_fully_vaccinated++;
                }
            }
        }
        total_count++;
    }, 1000/rate);
}

var table = $("#countryTable");

table.find('tr').each(function (i, el) {
    var $ths = $(this).find('td').find('a'),
        country = $ths.eq(0).attr('href').split('/')[$ths.eq(0).attr('href').split('/').length - 1];
    var $tds = $(this).find('td'),
        currentVax = parseInt($tds.eq(1).data(country+'total_vaccinations'));
        currentRate = $tds.eq(1).data(country+'rate');
    if (currentRate>0) {

        setInterval(function() {
            document.getElementById(country+'Current').innerHTML = currentVax.toLocaleString(lang_code);
            currentVax++;
        }, 1000/currentRate);
    }
});

var time = new Date().getTime();
$(document.body).bind("mousemove keypress", function(e) {
    time = new Date().getTime();
});

function refresh() {
    if(new Date().getTime() - time >= 300000) {
    window.location.reload(true);
    } else {
        setTimeout(refresh, 10000);
    }
}
setTimeout(refresh, 10000);

function searchTable() {
  // Declare variables
  var input, filter, table, tr, td, i, txtValue;
  input = document.getElementById("countrySearchInput");
  filter = input.value.toUpperCase();
  table = document.getElementById("countryTable");
  tr = table.getElementsByTagName("tr");
  var shownRows = 0;

  if (input.value.length > 0 && $('.smallNationRow').css('display')== 'none') {
      showSmallNations();
  }

  // Loop through all table rows, and hide those who don't match the search query
  for (i = 0; i < tr.length; i++) {
    td = tr[i].getElementsByTagName("td")[0];
    if (td) {
      txtValue = td.textContent || td.innerText;
      if (txtValue.toUpperCase().indexOf(filter) > -1) {
        tr[i].style.display = "";
        shownRows += 1;
      } else {
        tr[i].style.display = "none";
      }
    }
  }
  var noResultsRow = document.getElementById("noResultsRow");
  if (shownRows == 0) {
    noResultsRow.style.display = "";
  } else {
    noResultsRow.style.display = "none";
  }
}

function sortTable(n, isnum, sortdir) {
  var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
  table = document.getElementById("countryTable");
  var tableHeaderRow = document.getElementById("tableHeaderRow");
  var arrowSpanList = tableHeaderRow.getElementsByClassName("sortInd");

  for (j = 0; j < arrowSpanList.length; j++) {
      arrowSpanList[j].innerHTML = "";
  }

  var arrowSpan = arrowSpanList[n];
  switching = true;
  // Set the sorting direction to ascending:
  dir = sortdir;
  /* Make a loop that will continue until
  no switching has been done: */
  while (switching) {
    // Start by saying: no switching is done:
    switching = false;
    rows = table.rows;
    /* Loop through all table rows (except the
    first, which contains table headers): */
    for (i = 0; i < (rows.length - 1); i++) {
      // Start by saying there should be no switching:
      shouldSwitch = false;
      /* Get the two elements you want to compare,
      one from current row and one from the next: */
      x = rows[i].getElementsByTagName("TD")[n];
      y = rows[i + 1].getElementsByTagName("TD")[n];
      /* Check if the two rows should switch place,
      based on the direction, asc or desc: */
      if (dir == "asc") {
        if (isnum) {
            if (Number(x.textContent.replace(/,|[A-zÀ-ÿ]|%|\./g, '').split('(')[0]) > Number(y.textContent.replace(/,|[A-zÀ-ÿ]|%|\./g, '').split('(')[0])) {
                shouldSwitch = true;
                break;
            }
        } else {
            if (x.textContent.toLowerCase() > y.textContent.toLowerCase()) {
                // If so, mark as a switch and break the loop:
                shouldSwitch = true;
                break;
            }
        }
      } else if (dir == "desc") {
        if (isnum) {
            if (Number(x.textContent.replace(/,|[A-zÀ-ÿ]|%|\./g, '').split('(')[0]) < Number(y.textContent.replace(/,|[A-zÀ-ÿ]|%|\./g, '').split('(')[0])) {
                shouldSwitch = true;
                break;
            }
        } else {
            if (x.textContent.toLowerCase() < y.textContent.toLowerCase()) {
                // If so, mark as a switch and break the loop:
                shouldSwitch = true;
            break;
            }
        }
      }
    }
    if (shouldSwitch) {
      /* If a switch has been marked, make the switch
      and mark that a switch has been done: */
      rows[i].parentNode.insertBefore(rows[i - 1], rows[i]);
      switching = true;
      // Each time a switch is done, increase this count by 1:
      switchcount --;
    } else {
      /* If no switching has been done AND the direction is "asc",
      set the direction to "desc" and run the while loop again. */
      if (switchcount == 0 && dir == sortdir) {
        if (sortdir=="asc") {
            dir = "desc";
        } else {
            dir = "asc"
        }

        switching = true;
      }
    }
  }
  if (dir=="asc") {
    arrowSpan.innerHTML = "&uarr;";
  } else {
    arrowSpan.innerHTML = "&darr;";
  }
}
